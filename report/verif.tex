\subsection{Using the Verified Software Toolchain}
% VC
The Verified Software Toolchain uses Verifiable C to prove correctness of C programs.
Verifiable C consists of a language and a program logic.
The language of Verifiable C is a subset of CompCert's Clight~\cite{clight}.
Clight was introduced as an intermediate language in CompCert, where all expressions are pure and side-effect free.
The program logic of Verifiable C is a higher-order Separation Logic~\cite{sep} (an extension of Hoare Logic~\cite{hoare}).
VST includes many tools, proved theorems and Coq tactics to assist the user in writing a forward separation logic proof in Coq that relates Clight's semantics (as defined in CompCert) and a formal specification.

% work flow 
When proving the correctness of a C program, a VST user should first generate an equivalent Clight program.
CompCert includes the \texttt{clightgen} tool to do so. Then, the user should write a specification in Coq for each C function.
Finally, the user can prove the correctness of each function separately.
%The Coq goal starts with a Separation Triple (see below).

\subsubsection{Verifiable C's Separation Logic.}
% Hoare
Hoare Logic has been extensively studied and used.
The correctness of a program is represented by a Hoare triple $\{P\}~c~\{Q\}$, where $P$ and $Q$ are formulas (respectively called precondition and postcondiction), and $c$ is a program.
Hoare Logic's simple rules allow to derive Hoare triples. For instance, the composition rule states that, if $\{P\}~c_1~\{Q\}$ and $\{Q\}~c_2~\{R\}$ hold, then $\{P\}~c_1;c_2~\{R\}$ holds.

% SEP
Separation Logic is an extension of Hoare Logic. Correctness is still modeled with a triple $\{P\}~c~\{Q\}$. However, the formulas for preconditions and postconditions are augmented with a new operator $*$.
Informally, $P_1~*~P_2$ means that the heap (or memory) can be split into two disjoint parts, one where $P_1$ holds, and another where $P_2$ holds.
This operator is convenient when dealing with multiples objects in the memory.
For instance, if $\btrep(n,p)$ means that the node $n$ is represented in the memory at address $p$, then $\btrep(n_1,p_1)*\btrep(n_2,p_2)$ means that the two nodes are in the heap, at different addresses (in particular, $p_1\neq p_2$).
Without this operator, one would have to add many propositions of the form $p_1\neq p_2$ when describing multiple objects in the heap, making the proof harder.
Separation Logic also defines the \textit{magic wand} operator $\wand$. Informally, $P~\wand~Q$ means that if the heap is extended with a disjoint part where $P$ holds, then $Q$ holds on the total heap.
This is particularly useful to extract information from a separation construct. \todo{example: refer to the subnode\_rep lemma}

\def\prop{\lstinline[language=Coq]{PROP}}
\def\local{\lstinline[language=Coq]{LOCAL}}
\def\sep{\lstinline[language=Coq]{SEP}}

\subsubsection{Function Specification in Verifiable C.}
In Verifiable C, a precondition or postcondition formula consists in three sets: \prop, \local\ and \sep.
\prop\ contains assertions of type \texttt{Prop} in Coq.
\local\ binds local variables to values. For instance, one could write \texttt{temp \_a (Vint(Int.repr 0))} to state that local variable \texttt{a} is bound to 0.
\sep\ contains spatial assertions in separation logic. Writing \texttt{P;Q} in \sep\ means that $\texttt{P}~*~\texttt{Q}$ holds.
\textbf{Fig.}~\ref{spec} shows one of our specifications.
The precondition contains several requirements, like \texttt{next\_node c (get\_root r) = Some n}, meaning that \texttt{n} is the node pointed to by the partial cursor.
Comparing the \sep\ clauses of the precondition and postcondition allows to understand what happens in the memory.
Here, the relation is unchanged, while the cursor is modified to represent the one returned by the Coq function \texttt{moveToFirst} (see \textbf{Fig.}~\ref{movetofirst}).

\begin{figure}
\begin{lstlisting}[language=Coq]
Definition moveToFirst_spec : ident * funspec :=
  DECLARE _moveToFirst
  WITH r:relation val, c:cursor val, pc:val, n:node val
  PRE[ _node OF tptr tbtnode, _cursor OF tptr tcursor, _level OF tint ]
    PROP(partial_cursor c r; next_node c (get_root r) = Some n)
    LOCAL(temp _cursor pc; temp _node (getval n);
          temp _level (Vint(Int.repr(Zlength c))))
    SEP(relation_rep r; cursor_rep c r pc)
  POST[ tvoid ]
    PROP()
    LOCAL()
    SEP(relation_rep r; cursor_rep (moveToFirst n c (length c)) r pc).
\end{lstlisting}
\caption{Formal Specification of the \texttt{moveToFirst} function}
\label{spec}
\end{figure}


\subsection{\btrees\ Representation in Separation Logic}
\label{subsec:rep}
For each formal type, we need a representation predicate to specify how it is represented in the memory.
For instance, in the VST verification of Binary-Search Trees~\cite{vst}, the predicate \lstinline[language=Coq]{tree_rep (t: tree val) (p: val) : mpred} is defined.
Such predicates relate a formal structure to a statement on the content of the memory.
However, this statement (of type \texttt{mpred}) holds more information than the formal model.
For instance, when we express that some formal tree is represented in the memory, we need to say at which address is each node represented at.
These addresses are not part of the formal model.
Similarly, when using a Coq list as a formal model for an array, the memory actually contains more than the values in the list if the list's length is not as big as the allocated size of the array.

In previous VST proofs, there have been two main ways to deal with this additional information.
The first one is to give the extra information as an argument to the representation predicate.
When writing \lstinline[language=Coq]{tree_rep t p} for instance, to state that the formal tree \texttt{t} is represented at address \texttt{p}, the address \texttt{p} is a value that is needed by the memory predicate but not part of the formal model.
This approach has the benefit of making a clear distinction between the formal model and the additional information.
This also allows the user to access this information if needed.
For instance, one could prove the lemma \lstinline[language=Coq]{forall t p, tree_rep t p |-- valid_pointer p}.
However, this is not a convenient way to deal with information that is either not useful outside of the representation predicate, or more complex than a simple value.
Indeed, we don't need to prove anything about the filler values in a C array. %that are outside of the Coq list that represents it.
And it would not be convenient to give to \lstinline{tree_rep} all the values where each node is represented at.

Another solution is to existentially quantify over this additional information inside the representation predicate.
For instance, when representing an array with a list, one could define \lstinline{list_rep (l:list A) (p:val)} such that there exists some filler values in the memory.
Similarly, when defining \lstinline{tree_rep t p}, for each child \texttt{c} of \texttt{t}, we claim that there exists some value \texttt{pc} such that the C pointer to \texttt{c} in \texttt{t} contains \texttt{pc} and in separating conjunction, we have \lstinline{tree_rep c pc}.
This solution is perfect for hiding all the additional information that an external user do not need to see when looking at the specifications.
However, such information cannot be retrieved outside of the memory predicate.

For traditional \btrees, these two ways are sufficient. We can hide the addresses of the subnodes and the filler array values by quantifying existentially over them.
And we can use the root address as an argument to \lstinline[language=Coq]{tree_rep}.
However, we claim that this is not enough to deal with the representation of cursors.
Indeed, cursors hold pointers to nodes of a \btree.
The values used in the memory representation of a cursor should then be the same as the addresses where each node is represented at.
Using a quantifier over theses values would require to define \lstinline{cursor_rep} and \lstinline{relation_rep} together, but we want to be able to define several cursors on one relation.
Thus, we need these values to be apparent in the specification.
It wouldn't be enough to give the list of values used by the cursor as an argument, as we need the addresses of every node of the \btree, if the cursor was to change.
To solve this issue, we decided to define an augmented type for \btrees.
This type can be seen \textbf{Fig.}~\ref{coqtypes}.
The augmented type is parametrized by a Coq Type X, which can be either \texttt{unit} or \texttt{val}.
Using \texttt{val} allows to add the C address of each node, record or relation directly into the formal type.
An user can still reason about abstract \btrees\ with \texttt{btnode unit}.
Finally, an augmented cursor contains a list of augmented nodes, with their addresses.
If an augmented cursor \texttt{c} is correct with regards to an augmented relation \texttt{r}, and we have \lstinline{cursor_rep c r pc * relation_rep r n}, then the values of the C cursor corresponding to \texttt{c} are the addresses where each node is represented in te memory.
Our augmented type approach is a generalization of the first approach, giving additional values as argument.
However, because we need to give each address of the tree (not only the root), augmenting the formal type with these values has been the most convenient.
The separation between abstract structure and additional information is less visible at first, but we can easily define an erasure function that transforms augmented trees into trees of type \texttt{btnode unit}.

We then define the functions \texttt{btnode\_rep}, \texttt{cursor\_rep} and \texttt{relation\_rep} that are used to specify how each structure is represented in memory.
They use a combination of \texttt{data\_at} and \texttt{malloc\_token} defined by VST.
\textbf{Fig.}~\ref{btnoderep} (in the appendix) shows one of these definitions.
We then prove multiple lemmas about these representations. For instance, if a node is represented in the memory at some address $p$, then $p$ is a valid pointer.

\subsection{\btrees\ Verification}
% rep functions
% locals
We define properties of the \btrees\ and cursors that are required to prove correctness.
Such definitions include \texttt{partial\_cursor c r}, meaning that \texttt{c} is a correct cursor for relation \texttt{r} that stops at an internal node.
By correct, we mean that each node is the $n^{th}$ child of the previous node, where $n$ is the previous index.

% subnode, subnode_rep
We then prove multiple lemmas to help us reason with the memory representations of each structure.
For instance, the function \texttt{currNode} returns a pointer to the last node of a cursor.
In the verification proof, we need to access this pointer by proving that the current node is represented somewhere in the memory.
However, the function precondition only states that the root node is represented in the memory.
To solve this, we first need to prove that the current node is a subnode of the root.
This is done by proving the following theorem:
\begin{lstlisting}[language=Coq]
  forall X (c:cursor X) r,
  complete_cursor_correct_rel c r -> subnode (currNode c r) (get_root r)
\end{lstlisting}

We then need to prove that, if a node $root$ is represented in the heap, and some other node $n$ is a subnode of $root$, then $n$ is also represented in the heap.
This is true because the function \btrep\ calls itself recursively on each children (see \textbf{Fig.}~\ref{btnoderep}).
However, because \btrep\ is a separating clause, we can't simply use an implication. We need to rewrite it as a separation conjunction.
This is done by proving the following theorem, \textbf{subnode\_rep}:

\begin{lstlisting}[language=Coq]
  forall n root, subnode n root ->
  btnode_rep root = btnode_rep n * (btnode_rep n -* btnode_rep root)
\end{lstlisting}

\todo{explanation? explain wandframeelim? wouldn't it be too technical?}

% body proofs
After proving many such theorems and writing every function specification (see \textbf{Fig.}~\ref{spec}), we need to prove the correctness of each function.
These proofs consists in proving a Separation triple $\{P\}~c~\{Q\}$, where $P$ and $Q$ are the precondition and postcondition defined in the specification, and $c$ is the Clight function.
Each triple is proved by moving forward through $c$.
For instance, if the first instruction of $c$ is an assignment \texttt{a:=0}, using the \lstinline[language=Coq]{forward} tactic of VST will turn the proof goal $\{P\}~\texttt{a=0};~c'~\{Q\}$ into $\{P'\}~c'~\{Q\}$,
where $P'$ is $P$ with the new \local\ binding: \texttt{temp \_a (Vint(Int.repr 0))}.
Occasionally, other goals have to be proven.
Every time an array is accessed, we must prove that the index is in the right range.
Every time a pointer is dereferenced, we must prove that it is valid.
Even if VST is able to infer the next precondition to use for sequences of instructions, we must still provide loop invariants when going through a loop or a branching statement.
When calling another function of the \btrees\ library, we must prove that the precondition of this function holds.
Finally, when we went through every statement of $c$, we are left with a goal $\{P\}~\texttt{skip}~\{Q\}$, where $Q$ is the function postcondition, and $P$ is the new precondition obtained after moving through the program.
Such goals (called entailments) are proved using separation logic rules implemented in VST.

\subsection{Results}
\todo{TODO: what has been proved? what's left?}
In appendix, Section~\ref{subsec:proof} presents the VST proof of the function creating a new node.
